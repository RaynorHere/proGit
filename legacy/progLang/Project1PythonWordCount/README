WF.PY README

wf.py is a Python-written program that is designed to accept a .txt file as input, after which point it will read the document and create a dictionary object which will track and tabulate the incidence of each word in the document. That is, the program will take in each line of the .txt file, remove any punctuation, and set all characters to lower case (case difference resulting in different UNICODE values and thus, to the computer, different "words"), and then separate each line into tokens in the form of individual words. These words are then added to the dictionary object it creates at initiation (if they are not already present in the dictionary) or increments their "occurrence" value by 1 (if they are).

Upon execution, the program will output a prompt for the user to supply a .txt filename (or a path leading to it, if .txt's are located in a folder in the program's directory), which the program will then dissect and tabulate.
If no file is supplied after running, the program will default the Alice-in-Wonderland.txt file.

INCLUDED FILES
wf.py (The "driver" class [do we say that in Python? There's no MAIN() function...] - this program is self-contained)

EVALUATION OF PYTHON
Okay, so I'm a pretty cheap date when it comes to stuff like this, because I'm a huge language nerd. I've loved learning foreign languages since I was a kid, I'm fluent in ~3 and semi fluent in another 2. This has been a passion of mine for as long as I can remember, and it turns out that learning more computer languages is no different. 
I've always meant to learn Python in my downtime; I have an entire class that I downloaded off the net, but I've always been busy with something else; the timing has never been right. The fact that I had this class on my docket sort of licensed me to just sit back and wait. I SOMEWHAT regret that; I was expecting a little more breakdown on maybe some Python vocabulary before we just cut loose into writing (admittedly very simple) programs in class. Still, obviously, this assignment is gauged with the idea that we can learn on the fly, at least enough to write a simple word counter. I BELIEVE I've done that. I guess the grade will tell upon return.

As far as Python goes, it's incredibly simple to read, and if I'm honest, I almost miss some of Java's stricter grammatical rules. I'm so used to seeing type statements that my eyes usually use them as milemarkers when I'm looking through a program. It's much stranger to just have variables declared and assigned with no heading, and it makes traversing the file a little trickier.
The only other problem is just not knowing the specific keywords and native functions of Python. It's hard to know how to instantiate a new object or understand what dot-operator function I need to call to get at the elements within a dictionary or list or what have you.
Luckily, I would say it's infinitely easier to look up tutorials in Python on the web and apply them directly/literally when writing your own programs. The more free-form (interpreted) nature of Python means that those very same strict Java rules don't apply, and the computer won't immediately throw a great big sulk because you're missing a curly brace or a semicolon or a type is mismatched. So, it's obviously a double-edged sword, but I think the versatility and user-friendliness of Python wins out in the end, which is precisely why this assignment is something we're just kind of thrown to with the full acknowledgement that SOME of the students in this class (me) have never written a single stroke of Python in their lives.

The thing that I'm most excited by is that Python is built so newb-friendly that you would expect it to be a "baby's first programming language" AND NOTHING ELSE. Usually anything that's this forgiving and open is used exclusively as a way for people to get their foot in the door and then leave it behind for "grown-up languages". What I love so much is that Python is so heavily used in the "real world", meaning that we're not just taking up brain space to learn some introductory nonsense that we'll never use again: Python STAYS applicable. Statistically speaking, anway. I think we can all agree that there's nothing better than having justification to do something you like doing, and I definitely dig Python.