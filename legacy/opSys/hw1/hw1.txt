Annika McCain
Dr. Casey Kennington
CS 354 Programming Languages
30 August 2021

   P16:3 Why are there so many programming languages?
The main reasons that there are so many programming languages are evolution 
(has the field changes the code need to change with it), special purpose 
(certain languages are made for specific purposes), personal preferences 
(some people like high level languages others might like assembly), compilation
(compiled vs interpreted code), interpretation, and several others.

   P16:4: What makes a programming language successful?
The things that make a programming language successful are expressive power
(a big part is abstraction), ease of use for a novice (easy to learn and 
understand), ease of implementation, standardization (predefined libraries and
data elements), open source, excellent compilers, and economics, patronage, and
inertia (must meet the requirements of the customer and be flexible for new
advancements).

   P16:6: What distinguishes declarative langauges from imperative ones?
Declarative languages focuses on "what a computer is to do" and an imperative
one focuses on "how a computer should do it". A declarative language are a 
'higher level' and has no concern for implementation of procedures.

   P25:11: Explain the distinction between interpretation and compilation. What 
   are the comparative advantages and disadvantages of both?
Interpretaion is a single step process were the interpreter has complete control
of the execution of program and reads it line by line and executes simultaneously.
While compilation is a two step process that will first translate the program to 
machine language (object code) and then the user will then have control to 
execute the object code.

   P25:12: Is Java compiled or interpreted? Or Both? How do you know?
Java can be both as Java will first compile into bytecode (which allows platform
independence) then in ealier versions of Java it would use a byte-code interpreter
to execute the program but later versions started using a JIT compiler which 
translates the bytecode into machine language right before each execution.

   P36:24 Describe the form in which the scanner is passed from the scanner to 
   the parser; from the parser to the semantic analyzer; from the semantic 
   analyzer to the intermediate code generator.
The program will be passed to the scan in the form of sequences of characters
which are scanned individually to group them into tokens. The tokens will then
be passed to the paser which will generate a parse tree (this will determine the
structure of our program). The parse tree will the be passed from the parse to the
semantic analyzer to assign meaning to the program construct ansd will perform 
static and dymanic semantic checks to determine if there are errors in the program.
The semantic analysis will result in an abstract syntax tree (in intermediate code)
this will then be optimized using various techniques that will eliminate repetitive 
or unnecessary segments. Once optimized it will then be transfer to the code
generator.

   P38:1.1: 1.1 Errors in a computer program can be classified according to when 
   they are detected and, if they are detected at compile time, what part of the
   compiler detects them. Using your favorite imperative language, give an example 
   of each of the following.
(I will be using Java)
      (a) A lexical error, detected by the scanner
char c = 'abc';

      (b) A syntax error, detected by the parser
System.out.print("Error") //there needs to be a ;

      (c) A static semantic error, detected by semantic analysis
int x = 2;
String s = "abc";
System.out.println(x + s); //adding an int to a string

      (d) A dynamic semantic error, detected by code generated by the compiler
int i = 5/0; //trying to divide by zero

      (e) An error that the compiler can neither catch nor easily generate code 
      to catch (this should be a violation of the language definition, not just a 
      program bug)
String s;
if (false){
   System.out.print("HOW?"); //always unreachable
}
